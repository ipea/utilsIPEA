{
    "collab_server" : "",
    "contents" : "#' Check Brazilian names\n#'\n#' \\code{extrai_NomeProprio} Parse brazlian names and returns given names, surnames and gender\n#'\n#' @param x List, character or factor with names to be parsed.\n#' @param surname If TRUE, the list of surnames is returned.\n#' @param gender If TRUE, the list of gender based on the names is returned.\n#' @param stringdist if TRUE, make a prediction based on the string distance of Jaro-Winkler between the source data and the input.\n#' @param spaces if TRUE, returns the names without spaces. If FALSE, it compress all the blank spaces.\n#'\n#' @import data.table stringr stringdist\n#' @importFrom utils data\n#' @return Returns a data.table\n#'\n#' @examples\n#'   extrai_NomeProprio(x = c(\"Maria Conceicao da Costa\", \"Mario Silva\"), surname = TRUE)\n#' @export\nextrai_NomeProprio <- function(x, surname = FALSE, gender = FALSE, stringdist = TRUE, spaces = TRUE){\n  if(file.exists(\"data/names_gender.csv\")){\n    extrai_NomeProprio_(x = x, surname = surname, gender = gender, stringdist = stringdist, spaces = spaces)\n  } else {\n    print(\"Downloading source data...\")\n    require(RCurl)\n    url_base <- getURL(\"https://gist.githubusercontent.com/igornoberto/60eb1956e25c84c4b94b1f91f69017f0/raw/cbc007cd86342382327ab141463f4152b38fdc5e/nomes.csv\")\n    dir.create(paste0(getwd(),\"/data\"))\n    write.table(url_base,\"data/names_gender.csv\", sep = \",\", quote = FALSE)\n    extrai_NomeProprio_(x = x, surname = surname, gender = gender, stringdist = stringdist, spaces = spaces)\n  }\n}\n\n\nfind_strdist <- function(um_primeiro,dois_primeiros,tres_primeiros){\n  suppressWarnings(require(stringdist))\n  base_nomes <- suppressMessages(fread(\"data/names_gender.csv\"))\n  pos <- amatch(c(um_primeiro,dois_primeiros,tres_primeiros),base_nomes$V1, method = \"jw\", maxDist = 0.7)\n  pes1 <- stringdist(um_primeiro, base_nomes$V1[pos[1]], method = \"jw\")\n  pes2 <- stringdist(dois_primeiros, base_nomes$V1[pos[2]], method = \"jw\")\n  pes3 <- stringdist(tres_primeiros, base_nomes$V1[pos[3]], method = \"jw\")\n  minimo <- suppressWarnings(min(pes1,pes2,pes3, na.rm = TRUE))\n  retorno <- ifelse( minimo == pes1, base_nomes$V1[pos[1]],\n                     ifelse( minimo == pes2, base_nomes$V1[pos[2]],\n                             ifelse( minimo == pes3, base_nomes$V1[pos[3]],\n                                     NA)))\n  return(retorno)\n}\n\n\nextrai_NomeProprio_ <- function(x, surname, gender, stringdist, spaces){\n  NomeProprio <- NULL\n  um_primeiro <- NULL\n  dois_primeiros <- NULL\n  tres_primeiros <- NULL\n  nome <- NULL\n  . <- NULL\n  base_nomes <- NULL\n\n  if(!is.logical(surname)){\n    stop(\"surname should be a Logical value, TRUE or FALSE\")\n  }\n\n  if(!is.logical(gender)){\n    stop(\"gender should be a Logical value, TRUE or FALSE\")\n  }\n\n  if(!is.logical(stringdist)){\n    stop(\"stringdist should be a Logical value, TRUE or FALSE\")\n  }\n\n  if(!is.logical(spaces)){\n    stop(\"spaces should be a Logical value, TRUE or FALSE\")\n  }\n\n\n  #Carrega bases necessárias e variáveis--------------------------\n  base_nomes <- suppressMessages(fread(\"data/names_gender.csv\"))\n  patternOneName <- \"^[a-zA-Z0-9_]+\"\n  patternTwoNames <- \"^[a-zA-Z0-9_]+\\\\s[a-zA-Z0-9_]+\"\n  patternThreeNames <- \"^[a-zA-Z0-9_]+\\\\s[a-zA-Z0-9_]+\\\\s[a-zA-Z0-9_]+\"\n\n  #Trata os dados de entrada --------------------------------------\n  names <- setDT(data.frame(nome = toupper(x)))\n\n  #Separa nomes---------------------------------------------------\n  names[,um_primeiro := str_extract(nome,patternOneName)]\n  names[,dois_primeiros := str_extract(nome,patternTwoNames)]\n  names[,tres_primeiros := str_extract(nome,patternThreeNames)]\n\n  if(stringdist == TRUE){\n    names[, NomeProprio := ifelse(tres_primeiros %in% base_nomes$V1, tres_primeiros,\n                                  ifelse(dois_primeiros %in% base_nomes$V1, dois_primeiros,\n                                         ifelse(um_primeiro %in% base_nomes$V1, um_primeiro,\n                                                ifelse(!is.na(find_strdist(um_primeiro, dois_primeiros, tres_primeiros)), find_strdist(um_primeiro, dois_primeiros, tres_primeiros),\n                                                       um_primeiro))))]\n  }\n\n  if(stringdist == FALSE){\n    names[, NomeProprio := ifelse(tres_primeiros %in% base_nomes$V1, tres_primeiros,\n                                  ifelse(dois_primeiros %in% base_nomes$V1, dois_primeiros,\n                                         str_extract(names$nome,patternOneName)))]\n  }\n\n  if(surname == TRUE){\n    names[,surname := ifelse(str_replace_all(NomeProprio,\" \",\"\") == str_extract(nome,\"^[A-Z]+\"), str_replace(nome,\"^[A-Z]+\\\\s\",\"\"),\n                               str_trim(str_replace(nome, NomeProprio, \"\")))]\n  }\n  if(gender == TRUE){\n    names[,gender := base_nomes[NomeProprio,,on=\"V1\"][,.(V2)]]\n\n  }\n\n  if(spaces == FALSE){\n    names[,NomeProprio := str_replace_all(NomeProprio,\" \",\"\")]\n    names[,surname := str_replace_all(surname,\" \",\"\")]\n  }\n\n  names[,dois_primeiros := NULL]\n  names[,tres_primeiros := NULL]\n  names[,um_primeiro := NULL]\n  names[,nome := NULL]\n\n  if(surname == FALSE & gender == FALSE){\n    return(names[,NomeProprio])\n  }\n\n  return(names)\n}\n\n\n",
    "created" : 1507229210595.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "9309916",
    "id" : "FD21A4D6",
    "lastKnownWriteTime" : 1507310253,
    "last_content_update" : 1507310253,
    "path" : "K:/Igor N/WD/utilsIPEA/R/extrai_nome_proprio.R",
    "project_path" : "R/extrai_nome_proprio.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}